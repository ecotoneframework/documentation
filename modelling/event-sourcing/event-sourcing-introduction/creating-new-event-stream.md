# Creating New Event Stream

## Building an first Event Sourced Aggregate

Event Sourcing support is available via separate Ecotone's Module:

```php
composer require ecotone/pdo-event-sourcing
```

We need to configure [DBAL Support](../../../modules/dbal-support.md) in order to make use of it.

Ecotone PDO Event Sourcing does provide support for three databases:

* PostgreSQL
* MySQL
* MariaDB

{% hint style="success" %}
Ecotone provides inbuilt functionality to serialize your Events, which can be customized in case of need. This makes Ecotone take care of Event Serialization/Deserialization, and allows us to focus on the business side of the code. To make it happen it's enough to install [Ecotone JMS Converter](../../../modules/jms-converter.md).
{% endhint %}

## Setting up first Event Sourcing Aggregate

In [previous chapter ](./)we discussed that Event Sourcing Aggregates are built from Event Streams stored in the data store. Yet it's important to understand how those Events gets to the Event Stream in the first place.&#x20;

Just as with Standard Aggregate, ES Aggregates are called by Command Handlers, however what they return are Events and they do not change their internal state.

```php
#[EventSourcingAggregate]
class Product
{
    use WithAggregateVersioning;

    #[Identifier]
    private string $id;

    #[CommandHandler]
    public static function create(CreateProduct $command) : array
    {
        return [new ProductWasCreated($command->id, $command->name, $command->price)];
    }

    #[EventSourcingHandler]
    public function applyProductWasCreated(ProductWasCreated $event) : void
    {
        $this->id = $event->id;
    }
}
```

When this Aggregate will be called via Command Bus with **CreateProduct** Command, it will then return new **ProductWasCreated** Event.&#x20;

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="success" %}
Command Handlers may return single events, multiple events or no events at all, if nothing is meant to be changed.
{% endhint %}

What is important is that we always need to assign the Identifier for the Aggregate. So Ecotone knows what identifier should Event Stream for this specific Aggregate instance have:\
We do it via **EventSourcingHandler**, which is used for applying recorded Events.

```php
#[EventSourcingHandler]
public function applyProductWasCreated(ProductWasCreated $event) : void
{
    $this->id = $event->id;
}
```

We do not modify the state directly in the Command Handler, as those would only change the state now. Yet we want to be able to "restore" the Aggregate whenever it's being called from database. That's why we use EventSourcingHandler for.

## Two ways of setting up Event Sourced Aggregates

There are two ways we can configure our Aggregate to record Events.&#x20;

### 1) Pure Event Sourced Aggregate

This way of handling events does allow for pure functions. This means that actions called on the Aggregate returns Events and are not changing internal state of Aggregate.

```php
#[EventSourcingAggregate] // 1
class Ticket
{
    use WithAggregateVersioning; // 2

    #[Identifier] // 1
    private string $ticketId;
    private string $ticketType;

    #[CommandHandler] // 2
    public static function register(RegisterTicket $command) : array
    {
        return [new TicketWasRegistered($command->getTicketId(), $command->getTicketType())];
    }

    #[CommandHandler] // 2
    public function close(CloseTicket $command) : array
    {
        return [new TicketWasClosed($this->ticketId)];
    }

    #[EventSourcingHandler] // 4
    public function applyTicketWasRegistered(TicketWasRegistered $event) : void
    {
        $this->ticketId       = $event->getTicketId();
        $this->ticketType     = $event->getTicketType();
    }
}
```

1. `EventSourcingAggregate` and `Identifier` [works exactly the same as State-Stored Aggregate](../../command-handling/state-stored-aggregate/).
2. Event Sourced Aggregate must provide version. You may leave it to `Ecotone` using `WithAggregateVersioning` or you can implement it yourself.
3. `CommandHandler`for event sourcing returns events generated by specific method. This will be passed to the [`Repository`](../../command-handling/repository.md) to be stored.&#x20;
4. `EventSourcingHandler` is method responsible for reconstructing `Aggregate` from previously created events. At least one event need to be handled in order to provide `Identifier`.

### 2) Internal Recorder Aggregate

This way of handling events allow for similarity with [State Stored Aggregates](../../command-handling/state-stored-aggregate/).\
This convention requires changing internal state of Aggregate to record Events. \
Therefore Pure ES Aggregate is recommended as it's not require for any internal state changes in most of the scenarios. \
However ES Aggregate with Internal Recorder may be useful for projects migrating with other solutions, or when our team is heavily used to working this way.

```php
#[EventSourcingAggregate] 
class Basket
{
    use WithEvents; // 1
    use WithVersioning;

    #[Identifier]
    private string $id;

    #[CommandHandler] // 2
    public static function create(CreateBasket $command) : static
    {
        $basket = new static();
        $basket->recordThat(new BasketWasCreated($command->getId()));

        return $basket;
    }

    #[CommandHandler] // 2
    public function addProduct(AddProduct $command) : void
    {
        $this->recordThat(new ProductWasAddedToBasket($this->id, $command->getProductName()));
    }

    #[EventSourcingHandler]
    public function applyBasketWasCreated(BasketWasCreated $basketWasCreated)
    {
        $this->id = $basketWasCreated->getId();
    }
}
```

1. In order to make use of alternative way of handling events, we need to provide trait **WithEvents**.
2. Command Handlers instead of returning events are acting the same as [State Stored Aggregates](../../command-handling/state-stored-aggregate/).\
   All events which will be published using `recordThat`will be passed to the [`Repository`](../../command-handling/repository.md) to be stored.&#x20;
